/*Copyright (C) 2012 raohmaru <http://raohmaru.com>This file is part of Raohmaru Toolkit.Raohmaru Toolkit is free software: you can redistribute it and/or modifyit under the terms of the GNU Lesser General Public License as published bythe Free Software Foundation, either version 3 of the License, or(at your option) any later version.Raohmaru Toolkit is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty ofMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See theGNU Lesser General Public License for more details.You should have received a copy of the GNU Lesser General Public Licensealong with Raohmaru Toolkit.  If not, see <http://www.gnu.org/licenses/>.*/package jp.raohmaru.toolkit.utils{import jp.raohmaru.toolkit.motion.Paprika;import flash.display.DisplayObject;import flash.display.DisplayObjectContainer;import flash.display.Loader;import flash.geom.Rectangle;import flash.utils.ByteArray;import flash.utils.describeType;import flash.utils.getDefinitionByName;
/** * Métodos extendidos para el tratamiento de objetos y objetos de visualización.
 * @author raohmaru
 */
public class ObjectUtil{	/**	 * Clona un objeto que no sea un DisplayObject. No guarda referencias a instancias específicas.	 * Es mejor utilizar este método para objetos sencillos.	 * @param source Objeto a clonar	 * @return Nuevo objeto	 */	public static function clone(source:Object):*	{		var copier : ByteArray = new ByteArray();			copier.writeObject(source);			copier.position = 0;		return(copier.readObject());	}	/**	 * Duplica un DisplayObject de manera similar a duplicateMovieClip en AVM1.	 * <b>IMPORTANTE</b> El símbolo del movieclip duplicado debe estar exportado para ActionScript en la biblioteca.	 * @param target DisplayObject a duplicar	 * @param autoAdd Determina si se añade el objeto duplicado a la lista de visualización a la que pertenece el objeto original	 * @return Una instancia del objeto duplicado	 * @author Trevor McCauley (http://www.senocular.com/)	 */	public static function duplicateDisplayObject(target : DisplayObject, autoAdd:Boolean = false) : DisplayObject	{		// create duplicate		var targetClass : Class = Object(target).constructor as Class;		var duplicate : DisplayObject = new targetClass();		// duplicate properties		duplicate.transform = target.transform;		duplicate.filters = target.filters;		duplicate.cacheAsBitmap = target.cacheAsBitmap;		duplicate.opaqueBackground = target.opaqueBackground;		if(target.scale9Grid)		{			var rect : Rectangle = target.scale9Grid;			// WAS Flash 9 bug where returned scale9Grid is 20x larger than assigned			// rect.x /= 20, rect.y /= 20, rect.width /= 20, rect.height /= 20;			duplicate.scale9Grid = rect;		}		if (autoAdd && target.parent) target.parent.addChild(duplicate);		return duplicate;	}	/**	 * Crea una nueva instancia de una clase a partir de otra.	 * @param element Objeto cuya clase se clonará	 * @return Nuevo objeto clon	 */	public static function cloneElement(element : Object) : Object	{		var className:String = describeType(element).@name;		var ClassReference:Class = getDefinitionByName(className) as Class;		var clone:Object = new ClassReference(element);		return Object(clone);	}	/**	 * Elimina todos los elementos secundarios de una instancia DisplayObjectContainer y devuelve una matriz con esos elementos.	 * @param container El contenedor a vaciar	 * @return Matriz con los elementos elminiados	 */	public static function removeAllChildren(container : DisplayObjectContainer) : Array	{		var removed : Array = [];		//for(var i:int=0; i<container.numChildren; i++)		while(container.numChildren > 0)			removed.push( container.removeChildAt(0) );		return removed;	}	/**	 * Elimina todos los elementos secundarios de los objetos Loader del contenedor DisplayObjectContainer que se cargaron	 * utilizando el método <code>load()</code>.	 * @param container El contenedor a vaciar	 * @see Loader#load()	 */	public static function unloadAllChildren(container : DisplayObjectContainer) : void	{		var removed : Array = removeAllChildren(container),			i :int = 0;		while(i < removed.length)		{			if(removed[i] is Loader) Loader(removed[i]).unload();			i++;		}	}
	/**	 * Obtiene una matriz con todos los nodos secundarios del objeto DisplayObjectContainer especificado.	 * @param container Objeto contenedor de donde obtener los hijos.	 * @return Una matriz con todos los nodos secundarios.	 */    public static function getChildren(container :DisplayObjectContainer) :Array    {        return getChildrenByType(container, DisplayObject);    }	/**	 * Obtiene una matriz con todos los nodos secundarios del tipo especificado de un objeto DisplayObjectContainer.	 * @param container Objeto contenedor de donde obtener los hijos.	 * @param type Class La clase o tipo al que deben pertenecer los nodos secundarios.	 * @return Una matriz con todos los nodos secundarios.	 * @example	 * <listing version="3.0">	 * import jp.raohchan.utils.ObjectUtil;	 *	 * addChild(new Sprite());	 * addChild(new Sprite());	 * addChild(new Bitmap());	 *	 * trace( ObjectUtil.getChildrenByType(this, Sprite).length );  // 2	 * trace( ObjectUtil.getChildrenByType(this, Bitmap).length );   // 1	 * </listing>	 */    public static function getChildrenByType(container :DisplayObjectContainer, type :Class) :Array    {        var children :Array = [],        	numChildren :int = container.numChildren;        for(var i:int = 0; i<numChildren; i++)        {            if(container.getChildAt(i) is type)                children.push(container.getChildAt(i));        }        return children;    }	/**	 * Oculta y remueve de la lista de visualización un DisplayObject.	 * @param target Objeto DisplayObject a ocultar y eliminar.	 * @param time Duración de la transición en segundos.	 * @param delay Retraso en el inicio de la transición, en segundos.	 */	public static function hideAndRemove(target :DisplayObject, time :Number = .3, delay :Number = 0) : void	{		Paprika.add(target, time, {alpha:0}, null, delay, function() :void		{			if(target.parent) target.parent.removeChild(target);		});	}	/**	 * Crea una nueva instancia del objeto con el nombre de clase especificada como parámetro.	 * Es un atajo a vincular una clase con <code>new ClassReference()</code>, pero al estilo del viejo AS2.	 * FIXME No funciona en una pelicula cuando esta se carga como .swf externo en otra película	 * @param name Nombre de la clase del objeto a instanciar.	 * @return Una instancia del objeto vinculado.	 */	public static function attachAsset(name :String) :*	{		return new (Class(getDefinitionByName(name)));	}}
}